#! /usr/bin/env python

import sys
import traceback

import doit
from doit import main
from doit import cmdparse

DOIT_USAGE = """
doit -- automation tool
http://python-doit.sourceforge.net/

Commands:
 doit [run]             run tasks
 doit list              list tasks from dodo file
 doit template          create a dodo.py template file 

 doit help              show help / reference
 doit help <command>    show command usage
"""

## cmd line options
##########################################################
########## run
# print version and exit
opt_version = {'name': 'version',
               'short':'',
               'long': 'version',
               'type': bool,
               'default': False,
               'help': "show version"
               }

# display cmd line usage
opt_help = {'name': 'help',
            'short':'',
            'long': 'help',
            'type': bool,
            'default': False,
            'help':"show help"
            }

# select dodo file containing tasks
opt_dodo = {'name': 'dodoFile',
            'short':'f',
            'long': 'file',
            'type': str,
            'default': 'dodo.py',
            'help':"load task from dodo FILE [default: %(default)s]"
            }

# choose internal dependency file.
opt_depfile = {'name': 'dep_file',
               'short':'',
               'long': '',
               'type': str,
               'default': ".doit.dbm",
               'help': "file used to save successful runs"
               }

# always execute task
opt_always = {'name': 'always',
              'short': 'a',
              'long': 'always-execute',
              'type': bool,
              'default': False,
              'help': "always execute tasks even if up-to-date [default: "
                      "%(default)s]"
              }

# verbosity
opt_verbosity = {'name':'verbosity',
                 'short':'v',
                 'long':'verbosity',
                 'type':int,
                 'default': 0,
                 'help': """0 capture (do not print) stdout/stderr from task.
\t\t1 capture stdout only.
\t\t2 dont capture anything (print everything immediately).
\t\t[default: %(default)s]"""
                 }
run_doc = {'purpose': "run tasks",
           'usage': "[TASK/TARGET...]",
           'description': "#TODO"}

def cmd_run(params, args):
    """execute cmd run"""

    # special parameters that dont run anything
    if params["version"]:
        print ".".join([str(i) for i in doit.__version__])
        return 0
    if params["help"]:
        print DOIT_USAGE
        return 0


    # check if run command
    # default command is "run"
    if len(args) == 0 or args[0] not in params['sub']:
        filter_ = args
        task_list = main.load_task_generators(params['dodoFile'])
        return main.doit_run(params['dep_file'], task_list, filter_,
                            params['verbosity'], params['always'])

    # sub cmd provided on cmd line. parse arguments again
    commands = params['sub']
    sub_cmd = args.pop(0)
    # TODO help need 'sub' parameter. can i move it into cmdparse?
    return commands[sub_cmd](args, dodoFile=params['dodoFile'], sub=commands)



##########################################################
########## list

list_doc = {'purpose': "list tasks from dodo file",
            'usage': "",
            'description': "#TODO"}

opt_listall = {'name': 'all',
               'short':'',
               'long': 'all',
               'type': bool,
               'default': False,
               'help': "list include all sub-tasks from dodo file"
               }

# FIXME list should support "args" as a filter.
def cmd_list(params, args):
    task_list = main.load_task_generators(params['dodoFile'])
    return main.doit_list(task_list, params['all'])

##########################################################
########## template

template_doc = {'purpose': "create a dodo file from command line",
                'usage': "",
                'description': "#TODO"}

def cmd_template(params, args):
    print """
#dodo file. run pychecker and unittests.

import glob

pyFiles = glob.glob("lib/doit/*.py") + glob.glob("tests/*.py")

def task_checker():
    for file in pyFiles:
        yield {'action': "pyflakes %s"% file,
               'name':file,
               'dependencies':(file,)}

def task_nose():
    return {'action':"nosetests",
            'dependencies':pyFiles}

"""
    return 0




##########################################################
########## help

help_doc = {'purpose': "show help",
            'usage': "",
            'description': None}

def cmd_help(params, args):
    if len(args) == 1 and args[0] in params['sub']:
        params['sub'][args[0]].help()
    else:
        print DOIT_USAGE
    return 0





def cmd_main():
    subCmd = {} # all sub-commands

    # help command
    subCmd['help'] = cmdparse.Command('help', (), cmd_help, help_doc)

    # run command
    run_options = (opt_version, opt_help, opt_dodo,
                   opt_depfile, opt_always, opt_verbosity)
    subCmd['run'] = cmdparse.Command('run', run_options, cmd_run, run_doc)

    # list command
    list_options = (opt_dodo, opt_listall)
    subCmd['list'] = cmdparse.Command('list', list_options, cmd_list, list_doc)

    # template command
    subCmd['template'] = cmdparse.Command('template', () , cmd_template, template_doc)


    try:
        return subCmd['run'](sys.argv[1:], sub=subCmd)

    # in python 2.4 SystemExit and KeyboardInterrupt subclass
    # from Exception.
    # TODO maybe I should do something to help the user find out who
    # is raising SystemExit. because it shouldnt happen...
    except (SystemExit, KeyboardInterrupt), exp:
        raise

    # make sure exception is printed out. we migth have redirected stderr
    except Exception, e:
        sys.__stderr__.write(traceback.format_exc())
        return 1


if __name__ == "__main__":
    sys.exit(cmd_main())


#FIXME better error message when there is no dodo file.
# "                         when task doesnt exist.
