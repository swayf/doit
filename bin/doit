#! /usr/bin/env python

import sys
import traceback

from doit import __version__ as doit_version
from doit import main
from doit import task
from doit import cmdparse
from doit.cmds import doit_run, doit_clean, doit_list, doit_forget, doit_ignore


# TODO cmd list should be automatically generated.
DOIT_USAGE = """
doit -- automation tool
http://python-doit.sourceforge.net/

Commands:
 doit [run]             run tasks
 doit clean             clean action / remove targets
 doit list              list tasks from dodo file
 doit forget            clear successful run status from DB
 doit ignore            ignore task (skip) on subsequent runs
 doit dodo-sample       create a sample dodo.py file

 doit help              show help / reference
 doit help <command>    show command usage
"""

## cmd line options
##########################################################
########## run
# print version and exit
opt_version = {'name': 'version',
               'short':'',
               'long': 'version',
               'type': bool,
               'default': False,
               'help': "show version"
               }

# display cmd line usage
opt_help = {'name': 'help',
            'short':'',
            'long': 'help',
            'type': bool,
            'default': False,
            'help':"show help"
            }

# select dodo file containing tasks
opt_dodo = {'name': 'dodoFile',
            'short':'f',
            'long': 'file',
            'type': str,
            'default': 'dodo.py',
            'help':"load task from dodo FILE [default: %(default)s]"
            }

# select output file
opt_outfile = {'name': 'outfile',
            'short':'o',
            'long': 'output-file',
            'type': str,
            'default': None,
            'help':"write output into file [default: stdout]"
            }


# choose internal dependency file.
opt_depfile = {'name': 'dep_file',
               'short':'',
               'long': '',
               'type': str,
               'default': ".doit.db",
               'help': "file used to save successful runs"
               }

# always execute task
opt_always = {'name': 'always',
              'short': 'a',
              'long': 'always-execute',
              'type': bool,
              'default': False,
              'help': "always execute tasks even if up-to-date [default: "
                      "%(default)s]"
              }

# continue executing tasks even after a failure
opt_continue = {'name': 'continue',
                'short': 'c',
                'long': 'continue',
                'type': bool,
                'default': False,
                'help': "continue executing tasks even after a failure "
                        "[default: %(default)s]"
                }

# verbosity
opt_verbosity = {'name':'verbosity',
                 'short':'v',
                 'long':'verbosity',
                 'type':int,
                 'default': 0,
                 'help':
"""0 capture (do not print) stdout/stderr from task.
1 capture stdout only.
2 dont capture anything (print everything immediately).
[default: %(default)s]"""
                 }

# reporter
opt_reporter = {'name':'reporter',
                 'short':'r',
                 'long':'reporter',
                 'type':str, #TODO type choice
                 'default': 'default',
                 'help':
"""Choose output reporter. Available:
'default': report output on console
'executed-only': no output for skipped (up-to-date) and group tasks
'json': output result in json format
"""
                 }



run_doc = {'purpose': "run tasks",
           'usage': "[TASK/TARGET...]",
           'description': None}

def cmd_run(params, args):
    """execute cmd run"""

    # special parameters that dont run anything
    if params["version"]:
        print ".".join([str(i) for i in doit_version])
        return 0
    if params["help"]:
        print DOIT_USAGE
        return 0


    # check if command is "run". default command is "run"
    if len(args) == 0 or args[0] not in params['sub']:
        dodo_module = main.get_module(params['dodoFile'])
        command_names = params['sub'].keys()
        dodo_tasks = main.load_task_generators(dodo_module, command_names)
        filter_ = args or dodo_tasks['default_tasks']
        return doit_run(params['dep_file'], dodo_tasks['task_list'],
                        filter_, params['verbosity'], params['always'],
                        params['continue'], params['reporter'],
                        params['outfile'])

    # sub cmd different from "run" on cmd line. parse arguments again
    commands = params['sub']
    sub_cmd = args.pop(0)
    return commands[sub_cmd](args, dodoFile=params['dodoFile'], sub=commands)



##########################################################
########## list

list_doc = {'purpose': "list tasks from dodo file",
            'usage': "",
            'description': None}

opt_listall = {'name': 'all',
               'short':'',
               'long': 'all',
               'type': bool,
               'default': False,
               'help': "list include all sub-tasks from dodo file"
               }

opt_list_quiet = {'name': 'quiet',
                  'short': 'q',
                  'long': 'quiet',
                  'type': bool,
                  'default': False,
                  'help': 'print just task name (less verbose than default)'}

# TODO list should support "args" as a filter.
def cmd_list(params, args):
    dodo_module = main.get_module(params['dodoFile'])
    command_names = params['sub'].keys()
    dodo_tasks = main.load_task_generators(dodo_module, command_names)
    return doit_list(dodo_tasks['task_list'], params['all'], params['quiet'])

##########################################################
########## clean

clean_doc = {'purpose': "clean action / remove targets",
             'usage': "[TASK ...]",
             'description': None}

def cmd_clean(params, args):
    dodo_module = main.get_module(params['dodoFile'])
    command_names = params['sub'].keys()
    dodo_tasks = main.load_task_generators(dodo_module, command_names)
    return doit_clean(dodo_tasks['task_list'], args)


##########################################################
########## forget

forget_doc = {'purpose': "clear successful run status from internal DB",
              'usage': "[TASK ...]",
              'description': None}

def cmd_forget(params, args):
    dodo_module = main.get_module(params['dodoFile'])
    command_names = params['sub'].keys()
    dodo_tasks = main.load_task_generators(dodo_module, command_names)
    return doit_forget(params['dep_file'], dodo_tasks['task_list'], args)


##########################################################
########## ignore

ignore_doc = {'purpose': "ignore task (skip) on subsequent runs",
              'usage': "TASK [TASK ...]",
              'description': None}

def cmd_ignore(params, args):
    dodo_module = main.get_module(params['dodoFile'])
    command_names = params['sub'].keys()
    dodo_tasks = main.load_task_generators(dodo_module, command_names)
    return doit_ignore(params['dep_file'], dodo_tasks['task_list'], args)


##########################################################
########## dodo-sample

dodo_sample_description = \
"""Print a commented sample dodo file to stdout.
This file contains an example of all supported features."""

dodo_sample_doc = {'purpose': "create a dodo file from command line",
                   'usage': "",
                   'description': dodo_sample_description}

def cmd_dodo_sample(params, args):
    print """
## this is a quick reference. with small examples. for full instruction check
## the tutorial on the website.
## NOTE this file contains references for files that doesn't exist so you
## can NOT run it!

# name tasks that will be executed by default if nothing specified on
# command line
DEFAULT_TASKS = ['hello', 'py']


### task actions

# python-action
def my_function(foo, bar=0, zeta=0):
    # do whatever here
    #must return True to indicate it was completed successfully
    return True

# command-action
cmd_simple = "echo foo bar"
cmd_two = "echo more"


### tasks - a method that starts with the string "task_"
# it is actually a task generator. tasks are described by
# its: actions, dependencies, targets.

def task_hello():
    return {'actions': [cmd_simple, cmd_two],
            'dependencies': ['file1.txt'],
            'targets': ['target1.out']
            }


### python actions can also take args & kwargs passed in a tuple
def task_py():
    return {'actions': [(my_function, [5], {'zeta': 6})],
            }


### sub-task. create many tasks with same action. must have a name.
MY_FILES = ['file1.txt', 'file2.txt', 'file3.txt']
def task_many():
    for fin in MY_FILES:
        yield {'name': fin,
               'actions': ["echo %s" % fin]}


### dependencies can be another task. use ":" before task name
def task_target_dep():
    return {'actions': ["echo xxx"],
            'dependencies': [':many']
            }



### run task only once if target exist. set dependency "True"
def task_run_once():
    return {'actions': ["echo xxx > out.txt"],
            'dependencies': [True],
            'targets': ['out.txt']
            }


### group tasks. just set action to None. add group as dependencies.
def task_mygroup():
    return {'actions': None,
            'dependencies': [':py', ':run_once']
            }


### task setup env. good for functional tests!
# pass an object that optionally defines methods: "setup" and
# "cleanup". tasks can share the same object.
class SetupSample(object):
    def __init__(self, server):
        self.server = server
        self.executed = 0
        self.cleaned = 0

    def setup(self):
        # start server
        self.executed += 1

    def cleanup(self):
        # stop server
        self.cleaned += 1

setupX = SetupSample('x')
setupY = SetupSample('y')

def task_withenvX():
    for fin in MY_FILES:
        yield {'name': fin,
               'actions':['echo x'],
               'setup': setupX}

def task_withenvY():
    return {'actions':['echo x'],
            'setup': setupY}

"""
    return 0




##########################################################
########## help

help_doc = {'purpose': "show help",
            'usage': "",
            'description': None}

def cmd_help(params, args):
    if len(args) == 1 and args[0] in params['sub']:
        print params['sub'][args[0]].help()
    else:
        print DOIT_USAGE
    return 0


##########################################################



def cmd_main():
    subCmd = {} # all sub-commands

    # help command
    subCmd['help'] = cmdparse.Command('help', (), cmd_help, help_doc)

    # run command
    run_options = (opt_version, opt_help, opt_dodo, opt_depfile,
                   opt_always, opt_continue, opt_verbosity, opt_reporter,
                   opt_outfile)
    subCmd['run'] = cmdparse.Command('run', run_options, cmd_run, run_doc)

    # clean command
    clean_options = (opt_dodo,)
    subCmd['clean'] = cmdparse.Command('clean', clean_options, cmd_clean,
                                       clean_doc)

    # list command
    list_options = (opt_dodo, opt_listall, opt_list_quiet)
    subCmd['list'] = cmdparse.Command('list', list_options, cmd_list, list_doc)

    # forget command
    forget_options = (opt_dodo, opt_depfile,)
    subCmd['forget'] = cmdparse.Command('forget', forget_options,
                                        cmd_forget, forget_doc)

    # ignore command
    ignore_options = (opt_dodo, opt_depfile,)
    subCmd['ignore'] = cmdparse.Command('ignore', ignore_options,
                                        cmd_ignore, ignore_doc)

    # dodo-sample command
    subCmd['dodo-sample'] = cmdparse.Command('dodo-sample', () ,
                                             cmd_dodo_sample, dodo_sample_doc)


    try:
        return subCmd['run'](sys.argv[1:], sub=subCmd)

    # wrong command line usage. help user
    except cmdparse.CmdParseError, err:
        print str(err)
        return 1

    # in python 2.4 SystemExit and KeyboardInterrupt subclass
    # from Exception.
    # TODO maybe I should do something to help the user find out who
    # is raising SystemExit. because it shouldnt happen...
    except (SystemExit, KeyboardInterrupt), exp:
        raise

    # dont show traceback for user errors.
    except (main.InvalidDodoFile, main.InvalidCommand, task.InvalidTask), err:
        print "ERROR:", str(err)
        return 1

    # make sure exception is printed out. we migth have redirected stderr
    except Exception, e:
        sys.__stderr__.write(traceback.format_exc())
        return 1


if __name__ == "__main__":
    sys.exit(cmd_main())
