#! /usr/bin/env python

import sys
import traceback

import doit
from doit import main
from doit import cmdparse

# usage="usage: %prog [options] [task] [task] ...",

# "list"  help="list tasks from dodo file")
# --list-all"  help="list all tasks and sub-tasks from dodo file")

## cmd line options

##########################################################
########## run
# print version and exit
opt_version = {'name': 'version',
               'short':'',
               'long': 'version',
               'type': bool,
               'default': False}

# display cmd line usage
opt_help = {'name': 'help',
            'short':'',
            'long': 'help',
            'type': bool,
            'default': False}

# select dodo file containing tasks
# "load task from dodo FILE [default: %default]")
opt_dodo = {'name': 'dodoFile',
            'short':'f',
            'long': 'file',
            'type': str,
            'default': 'dodo.py'}

# choose internal dependency file.
opt_depfile = {'name': 'dep_file',
               'short':'',
               'long': '',
               'type': str,
               'default': ".doit.dbm"}

#
# always execute tasks even if up-to-date [default: %default]")
opt_always = {'name':'always',
              'short':'a',
              'long':'always-execute',
              'type':bool,
              'default': False}

#"-v", "--verbosity", default=0,
# help="""0 capture (do not print) stdout/stderr from task. \t
#         1 capture stdout only. \t
#         2 dont capture anything (print everything immediately). \t
#                           [default: %default]""")
opt_verbosity = {'name':'verbosity',
                 'short':'v',
                 'long':'verbosity',
                 'type':int,
                 'default': 0}


def cmd_run(params, args):
    """execute cmd run"""

    # special parameters that dont run anything
    if params["version"]:
        print ".".join([str(i) for i in doit.__version__])
        return 0
    if params["help"]:
        print "usage help"
        return 0


    # check if run command
    # default command is "run"
    if len(args) == 0 or args[0] not in params['sub']:
        filter_ = args
        task_list = main.load_task_generators(params['dodoFile'])
        return main.doit_run(params['dep_file'], task_list, filter_,
                            params['verbosity'], params['always'])

    # sub cmd provided on cmd line. parse arguments again
    commands = params['sub']
    sub_cmd = args.pop(0)
    return commands[sub_cmd](args, dodoFile=params['dodoFile'])



##########################################################
########## list


opt_listall = {'name': 'all',
               'short':'',
               'long': 'all',
               'type': bool,
               'default': False}

# FIXME list should support "args" as a filter.
def cmd_list(params, args):
    task_list = main.load_task_generators(params['dodoFile'])
    return main.doit_list(task_list, params['all'])


def cmd_main():
    subCmd = {} # all sub-commands

    # run command
    run_options = (opt_version, opt_help, opt_dodo,
                   opt_depfile, opt_always, opt_verbosity)
    subCmd['run'] = cmdparse.Command('run', run_options, cmd_run)

    # list command
    list_options = (opt_dodo, opt_listall)
    subCmd['list'] = cmdparse.Command('list', list_options, cmd_list)


    try:
        return subCmd['run'](sys.argv[1:], sub=subCmd)

    # in python 2.4 SystemExit and KeyboardInterrupt subclass
    # from Exception.
    # TODO maybe I should do something to help the user find out who
    # is raising SystemExit. because it shouldnt happen...
    except (SystemExit, KeyboardInterrupt), exp:
        raise

    # make sure exception is printed out. we migth have redirected stderr
    except Exception, e:
        sys.__stderr__.write(traceback.format_exc())
        return 1


if __name__ == "__main__":
    sys.exit(cmd_main())


#FIXME better error message when there is no dodo file.
# "                         when task doesnt exist.
